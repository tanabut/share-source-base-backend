import { Connection } from 'typeorm';

import { mockData } from '../__scripts/mockDb';

let connection: Connection;

type EntityMap = {
  name: string;
  tableName: string;
};

async function getEntities() {
  const dbEntities: EntityMap[] = [];
  (await (await connection).entityMetadatas).forEach(x =>
    dbEntities.push({ name: x.name, tableName: x.tableName }),
  );
  return dbEntities;
}

async function cleanMocks(entities: EntityMap[]) {
  try {
    await Promise.all(
      entities.map(async entity => {
        // Do not clear required seed tables
        if (
          ['Region', 'Province', 'District', 'Subdistrict'].includes(
            entity.name,
          )
        ) {
          return;
        }
        // Delete table data
        await connection.query(`TRUNCATE TABLE ${entity.tableName} CASCADE;`);
        // Reset sequence for tables with autogenerated sequence IDs
        await connection.query(`
        do $$
        begin
          IF EXISTS (SELECT 0 FROM pg_class where relname = '${entity.tableName}_id_seq')
            THEN PERFORM setval(pg_get_serial_sequence('${entity.tableName}', 'id'), coalesce(max(id),0) + 1, false) from "${entity.tableName}";
          END IF;
        end;
        $$
        `);
      }),
    );
  } catch (error) {
    throw new Error(`ERROR: Cleaning test db: ${error}`);
  }
}

export async function setupDatabase(dbConnection: Connection) {
  connection = dbConnection;

  if (!dbConnection) {
    throw new Error(
      'Cannot establish connection to test database. Please check config',
    );
  }

  await connection.synchronize(true);
}

export async function clearDatabase() {
  if (connection) {
    await connection.dropDatabase();
    await connection.close();
  }
}

export function getConnection() {
  return connection;
}

export async function resetData() {
  const dbEntities = await getEntities();
  await cleanMocks(dbEntities);
  await mockData();
}
